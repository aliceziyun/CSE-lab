#include <iostream>
#include <fstream>
#include <sstream>
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/types.h>
#include <dirent.h>
#include <algorithm>

#include <mutex>
#include <string>
#include <vector>
#include <map>

#include "rpc.h"
#include "mr_protocol.h"

using namespace std;

struct KeyVal
{
	string key;
	string val;
};

bool isIndex2End(char s)
{
	if (s == ' ' || s == '\0')
		return false;
	if ((s >= 'a' && s <= 'z') || (s <= 'Z' && s >= 'A'))
		return true;
	return false;
}

//
// The map function is called once for each file of input. The first
// argument is the name of the input file, and the second is the
// file's complete contents. You should ignore the input file name,
// and look only at the contents argument. The return value is a slice
// of key/value pairs.
//
vector<KeyVal> Map(const string &filename, const string &content)
{
	// Copy your code from mr_sequential.cc here.
	vector<KeyVal> ret;

	int index1 = 0, index2 = 0;
	while (content[index1] != '\0')
	{
		while (isIndex2End(content[index2]))
		{
			index2++;
		}
		string key = content.substr(index1, index2 - index1);
		if (key != "")
		{
			string val = "1";
			// cout << "key：" << key << endl;
			KeyVal kv;
			kv.key = key;
			kv.val = val;
			ret.push_back(kv);
		}
		index1 = index2;
		if (content[index1] == '\0')
			break;
		index1++;
		index2++;
	}
	cout << "map ok" << endl;
	return ret;
}

//
// The reduce function is called once for each key generated by the
// map tasks, with a list of all the values created for that key by
// any map task.
//
string Reduce(const string &key, const vector<string> &values)
{
	// Copy your code from mr_sequential.cc here.
	// cout << "reduce key" << key << endl;
	string ret = "0";

	int size = values.size();
	for (int i = 0; i < size; i++)
		ret = to_string(stol(ret) + stol(values[i]));
	return ret;
}

typedef vector<KeyVal> (*MAPF)(const string &key, const string &value);
typedef string (*REDUCEF)(const string &key, const vector<string> &values);

class Worker
{
public:
	Worker(const string &dst, const string &dir, MAPF mf, REDUCEF rf);

	void doWork();

private:
	void doMap(int index, const string &filename);
	void doReduce(int index, int file_nums);
	void doSubmit(mr_tasktype taskType, int index);

	mutex mtx;
	int id;

	rpcc *cl;
	std::string basedir;
	MAPF mapf;
	REDUCEF reducef;

	bool isWorking = false;
};

Worker::Worker(const string &dst, const string &dir, MAPF mf, REDUCEF rf)
{
	this->basedir = dir;
	this->mapf = mf;
	this->reducef = rf;

	sockaddr_in dstsock;
	make_sockaddr(dst.c_str(), &dstsock);
	this->cl = new rpcc(dstsock);
	if (this->cl->bind() < 0)
	{
		printf("mr worker: call bind error\n");
	}
}

int strHash(const string &str)
{
	unsigned int hashVal = 0;
	for (char ch : str)
	{
		hashVal = hashVal * 112 + (int)ch;
	}
	return hashVal % REDUCER_COUNT;
}

void Worker::doMap(int index, const string &filename)
{
	// Lab4: Your code goes here.
	isWorking = true;
	string content;
	getline(ifstream(filename), content, '\0');

	vector<KeyVal> keyVals = Map(filename, content);

	string intermediate_pre;
	intermediate_pre = basedir + "mr-" + to_string(index) + "-";
	// intermediate_pre = basedir + "mr-";

	vector<string> intermediates(REDUCER_COUNT);

	for (const KeyVal &keyVal : keyVals)
	{
		int reducerId = strHash(keyVal.key); // 这样可以确保一个词只会被分到一个reducer那里，这样就不会产生多条记录了
		intermediates[reducerId] += keyVal.key + ' ' + keyVal.val + '\n';
	}

	for (int i = 0; i < REDUCER_COUNT; ++i)
	{
		const string &intermediate = intermediates[i];
		if (!intermediate.empty())
		{
			string intermediate_file = intermediate_pre + to_string(i);
			ofstream file(intermediate_file, ios::out);
			file << intermediate;
			file.close();
		}
	}
}

void Worker::doReduce(int index, int file_nums)
{
	// Lab4: Your code goes here.
	isWorking = true;
	vector<KeyVal> intermediate;

	// cout<<"reduce task"<<endl;

	ofstream mrOut(basedir + "mr-out", ios::out | ios::app);

	for (int i = 0; i < file_nums; ++i)
	{
		string filepath = basedir + "mr-" + to_string(i) + '-' + to_string(index); // 还原path
		// string filepath = basedir + "mr-" + to_string(index);
		ifstream file(filepath, ios::in);
		string key, value;

		while (file >> key >> value)
		{
			KeyVal kv;
			kv.key = key;
			kv.val = value;
			intermediate.push_back(kv);
		}

		sort(intermediate.begin(), intermediate.end(),
			 [](KeyVal const &a, KeyVal const &b)
			 {
				 return a.key < b.key;
			 });

		file.close();
	}

	for (unsigned int i = 0; i < intermediate.size();)
	{
		unsigned int j = i + 1;
		for (; j < intermediate.size() && intermediate[j].key == intermediate[i].key;)
			j++;

		vector<string> values;
		for (unsigned int k = i; k < j; k++)
		{
			values.push_back(intermediate[k].val);
		}
		string count = Reduce(intermediate[i].key, values);
		string output = intermediate[i].key + " " + count;
		// printf("%s %s\n", intermediate[i].key.data(), output.data());
		mrOut << output << endl;

		i = j;
	}

	mrOut.close();
}

void Worker::doSubmit(mr_tasktype taskType, int index)
{
	bool b;
	mr_protocol::status ret = this->cl->call(mr_protocol::submittask, taskType, index, b);
	if (ret != mr_protocol::OK)
	{
		fprintf(stderr, "submit task failed\n");
		exit(-1);
	}
	isWorking = false;
}

void Worker::doWork()
{
	for (;;)
	{
		//
		// Lab4: Your code goes here.
		// Hints: send asktask RPC call to coordinator
		// if mr_tasktype::MAP, then doMap and doSubmit
		// if mr_tasktype::REDUCE, then doReduce and doSubmit
		// if mr_tasktype::NONE, meaning currently no work is needed, then sleep
		//
		mr_protocol::AskTaskResponse res;
		cout << "do work" << endl;
		if (!isWorking)
			cl->call(mr_protocol::asktask, id, res);
		switch (res.tasktype)
		{
		case MAP:
			cout << "worker: receive map task " << res.index << endl;
			doMap(res.index, res.filename);
			doSubmit(MAP, res.index);
			break;
		case REDUCE:
			cout << "worker: receive reduce task" << res.index << endl;
			doReduce(res.index, res.file_nums);
			doSubmit(REDUCE, res.index);
			break;
		case NONE:
			cout << "worker: receive no task" << endl;
			sleep(1);
			break;
		}
	}
}

int main(int argc, char **argv)
{
	if (argc != 3)
	{
		fprintf(stderr, "Usage: %s <coordinator_listen_port> <intermediate_file_dir> \n", argv[0]);
		exit(1);
	}

	MAPF mf = Map;
	REDUCEF rf = Reduce;

	Worker w(argv[1], argv[2], mf, rf);
	w.doWork();

	return 0;
}
